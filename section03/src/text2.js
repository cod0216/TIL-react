/*
Meta --> facebook이 개발한 프론트를 위해 개발한 오픈소스 JavaScript 라이브러리이다.

복잡한 대규모 웹 서비스를 좀 더 편하고 빠르게 개발할 수 있는 기술이다.

넷플릭스, 페이스북, 노션, 인스타 처럼 이런 대규모 서비스들을 지탱하고 있는 기술로써
활발히 사용되고 있음

오늘날 가장 많이 인기를 얻고 있는 프론트엔드 기술이다.

해외 뿐만 아니라 국내에서도 가장 많이 인기를 얻고 있는 기술이다.


## 리엑트의 기술적 특징

1. 컴포넌트를 기반으로 UI를 표현한다.
2. 화면 업데이트 구현이 쉽다.
3. 화면 업데이트가 빠르게 처리된다.


모든 내용을 환벽히 이해할 필요는 없다.
--> 대략적으로 흝어보듯이 들어보길 권장한다. 완강 이후에 다시 돌아오는걸 권장한다.



### 1. 컴포넌트를 기반으로 UI를 표현한다.

컴포넌트(Component)란 우리말로 구성요소 라는 듯이다.
화면을 구성하는 요소, UI를 구성하는 요소를 말한다.

<웹 페이지>
Header  --> header.js
Main    --> Main.js
Footer  --> Footer.js


각각의 js파일을 컴포넌트 단위로 나눠서 모듈호 할 수 있기 때문에 web페이지를 레고를 조립하듯이 여러게의 컴포넌트들을
합쳐서 만들어 낼 수 있다.

이렇게 모듈화 할 수 있다는 것은

중복코드를 제거하는 관점에서 매우 큰 장점이 된다.

페이지 A, 페이지 B에 공통적으로 Header가 들어간다면 
모든 페이지에 특별한 방법으로 모듈화를 하지 않는다면 
HTML 코드로 마크업() UI 구현이라고 생각하면 된다.)을 해야줘 된다.

이러한 방식으로 작업을 한다면 당연히 중복 코드가 발생한다.

이렇게 중복코드가 발생하게 되면 가벼운 수정 사항이 생긴다면 이 파일 저 파일 여기저기 많아진다면
페이지의 숫자가 늘어나면 늘어날 수록 우리가 코드를 수정하고 유지보수하는 일이 굉장히 힘들어지게 된다.

react를 이용한다면 이러한 문제를 격지 않아도 된다.

Header.js 컴포넌트를 만들고 여러 페이지에서 이 컴포넌트를 불러와서 사용하면 된다.

에초에 중복 코드가 발생하지 않기 때문에 사용하는게 좋고 유지 보수 차원에서도 이걸 사용하는게 더 좋다.



### 2. 화면 업데이트 구현이 쉽다.

업데이트란?
사용자의 행동(클릭, 드래그)에 따라 웹 페이지가 스스로 모습을 바궈 상호작용하는 것을 의미한다. 

버튼을 클릭했을때 버튼의 모양이 변화하는 것처럼 사용자의 어떤 행동에 따라서 클릭이나 드래그와 같은 행동에 따라서
웹 페이지가 스스로 자신의 모습을 바꿔 사용자와 상호작용 하는 모든 기능들을 일컫는다. 

그리고 React에서는 이러한 업데이트를 구현하기가 매우 쉽다.

리엑트는 "선언형 프로그래밍"이라는 방식으로 동작하기 때문이다.

선언형 프로그래밍이란?
불필요한 과정은 생략하고 내가 이루고자 하는 목저간 간결히 명시하는 방법을 ㅏㄹ한다.

마치 우리가 식당에서 음식을 주문하는 것과 유사하다
" 토마토 파스타 하나 주세요"
토마토 파스타를 만드는 과정은 난 잘 모르겠고 그냥 내 목적은 토마토 파스타다 
목적만 선언형으로 이야기 하는것이다.


반대로 명령형 프로그래밍이란?

목적을 이루기 위해 모든 일련의 과정을 하나하나 설명하는 방식을 말한다.

마치 진상손님처럼 주문하는 방식이다.
"주방으로 가셔서 면 100g을 꺼내세요, 그리고 뜨거운 물에 9분간 삶으세요
그런 다음 후라이팬을 꺼내 불을 올리고 토마토 소스와 함께 볶으세요
다 되었다면 접시에 담아서나에게 가져와 주세요"


정리하자면 
리엑트 (선언형 프로그래밍)
- 목적만 갈끔하게 명시한다.
- 코드가 간결하다.

자바스크립트(명령형 프로그래밍)
- 모든 과정을 하나하나 다 설명
- 코드가 길고 복잡함


특별한 코드를 사용하지 않는 이상 보통은 명령형 프로그래밍 방식으로 구현해야 하기 때문에 코드가 길고 복잡해 질 수 있다.

리엑트에서는 선언형 프로그래밍 방식으로 동작하기 때문에 아주 간단하게 화면을 업데이트 할 수 있다.

리엑트에서는 화면을 컴포넌트 단위로 나눠서 개발하레 된다. 이때 각각의 컴포넌트에서는 
state라는 현재 이 컴포넌트의 상태를 저장하는 아주 특수한 변수를 저장할 수 있다.
이 state가 바뀌면 컴포넌트가 바뀐 state값에 따라서 각각 다른 UI를 렌더링 할 수 있도록 설정할 수 있다.
여기서 렌더링이란 UI요소를 화면에 그려내는 것을 말한다.

state가 1번 --> 1번 UI
state가 2번 --> 2번 UI

리엑트에서는 C 컴포넌트가 state변수값에 따라서 
1에 따라서 1번 UI를 렌더링
2번이면 2번 UI를 렌더링 한다.

정리하자면
업데이터를 위한 복잡한 동작을 직접 정의할 필요 없이
특정 변수의 값을 바꾸는 것 만으로도 화면을 업데이트 시킬 수 있다.

리엑트에서는 복잡한 여러가지 동작들을 우리가 명령형 방식으로 직접 정의할 필요가 없이
그냥 특정 변수의 값만 바꿔주면 선언형 방식으로 해당 변수의 값에 따라서 화면이 업데이트 되도록 처리할 수 있다.


### 3. 화면 업데이트가 빠르게 처리된다.

화면 업데이트를 쉽게 구현할 수 있으면서 동시에 빠르게도 처리해ㅜㄴ다.

리엑트는 화면 업데이트를 매우 쉽게 구현할 수 있음과 동시에 이러한 업데이트 들을 매우 빠른 속도로 처리될 수 있도록 도와준다.

어떻게 그럴 수 있을까?

### 브라우저 동작 순서
[선수 지식 필요]

브라우저는 어떻게 동작하는가?
HTML, CSS로 만든 페이지를 어떻게 렌더링 하는가?
화면 업데이트는 어떻게 처리 되는가?


브라우저는 여러가지 과정을 통해서 렌더링을 하게 된다.
HTML --> DOM --> Render Tree --> Layout --> Painting
CSS --> CSSOM --> Render Tree --> Layout --> Painting

브라우저는 HTML CSS로 작성한 웹 페이지를 이러한 여러 단계를 거처서 화면에 렌더링 시켜준다.
이때 브라우저의 전체 과정을 우리가 웹 페이지를 렌더링 하기 위해 반드시 거쳐야 하는 중요한 경로다 라는 뜻에서
영어로는 Critical Rendering Path(부라우저 렌더링 과정) 라고 부른다.

핵심 기본 중 하나다.


첫 동작은 
HTML --> DOM (요소들의 위치, 배치, 모양에 관한 모든 정보)
CSS --< CSSOM(CSS Object Model) (요소들의 스타일과 관련된 모든 정보)로 변환하게 된다.

DOM이란
<div> 
  <header>
    <p> 헤더 </p>
  </header>
  <main>
    <p> 메인</p>
  </main>
</div>

위 HTML 코드를 브라우저가 이해하기 더 쉬운 방식으로 변환한 방식이다.

DOM(Document Object Model)로 변환한다.

div  -- header --> p --> "헤더"
    |
     -- main --> p --> "메인"


Html 문서를 일종의 객체 모델로 변환한거다 라고 해서 문서 객체 모델 Document Object Model이라고 한다.
CSSOM 또한 브라우저가 이해하기 쉬운 방식으로 변환한 모델이라고 생각하면 된다.

그래서 HTML과 CSS 코드를 각각 DOM, 과 CSSOM 으로 변환하고 나면 

방금 만든 DOM과 CSSOM을 합쳐서 Render Tree라는걸 만들게 된다. Render Tree는 웹페이지의 청사진, 설계도 정도의 역할을 한다.

Dom에는 우리가 HTML로 표현한 요소들의 위치나 배치 모양들에 관한 정보가 있을거고 그리고 CSSOM에는 CSS로 표현한 요소들의 스타일에 관련한
모든 요소들이 있을거다. 그렇기 떄문에 이 두개를 합쳐서 만든 Redner Tree에는 화면에 렌더링 되어야 하는 요소들의 모든 정보들을 포함해야 된다.

이렇게 RenderTree가 만들어 지면 Layout을 만들게 된다.

LayOut은 우리가 일상생활에서 방을 꾸밀때 침대는 어디에 두고, 책상은 어느쪽에 어느 방향으로 두고 할때 LayOut을 잡다 라고 표현한다.
그래서 LayOut은 요소의 배치를 잡는 작어이라고 한다.

Painting은 실제로 화면을 그려내는 과정이다.
이 과정을 거치게 되면 웹페이지가 실제로 눈에 나타나게 된다.

그렇다면 화면에 업데이트는 어떻게 이루어 질까?

Javascript가 Dom을 수정하면 업데이트가 일어나게 된다.

Dom이 수정되면 웹 페이지는 Critical Render 단계를 다시 수행하게 된다.

그래서 렌더 트리를 다시 수정하고 LayOut을 다시 잡고 페인팅을 다시 진행한다.
그러므로써 화면에 렌더링 되는 요소가 변경이 되면서 실제로 업데이트가 진행되게 된다.

그런데 여기서 한가지 주의 해야되는게 있다.

그게 뭐냐면 

이 크리티컬 렌더링 페스에서 전체 과정에서 
3단계에 해당하는 LayOut과 4단계에 해당하는 Painting은 꽤나 오래 걸리는 과정이다. 
그렇기 때문에 Dom이 수정되어서 Layout이 다시 그려지는것을 리플로우 라고 하고
painting이 다시 진행되는걸 리페인팅 이라고 부른다.

이렇게 별도로 부르는 이름이 있을 정도로 두 과정은 오래 걸리는 과정이다. 

그렇기 때문에 DOM을 JS로 3000번 수정하면 Render Tree 이후의 과정을 3000번 다시 진행하게 되는거니가

Layout을 다시 그리는 ReFlow와 painting을 다시 그리는 RePainting을 3000번이나 다시 수행하게 된다.

그러면 Reflow와 Repainting 과정은 오래 걸리는 과정이라고 했으니가 성능이 공장히 악화가 될 수 있다.

그래서 정말 심할 경우에는 응답없음 페이지를 띄워 아예 마비가 되는 현상이 발생할 수 있다.



*/

/*
<script>
  function onClick() {
    const $ul = Document.getElementById("ul");
    for(let i = 0; i < 3000; i++) {
      $sul.innerHTML += `<li>${i}</li>`;    
    }
  }
</script>

<body>
  <button onclick="onClick()">리스트 추가하기</button>
  <ul id="ul"></ul>
</body>
 */

/*
이렇게 코드를 작성하면 아주아주 큰 성능 문제를 겪게 된다.

3000번의 Dom을 수정하면 성능 측정 결과 4,500ms가 걸린다.



<script>
  function onClick() {
    const $ul = Document.getElementById("ul");
    let list = "";

    for(let i = 0; i < 3000; i++) {
      list += `<li>${i}</li>`;    // 반복문을 변수에 저장하고
    }
    
    $ul.innerHTML = list; // 한번만 돔을 수정하게 해야 된다.
  }
</script>

이렇게 수정해야 된다.
*/

/*
Js가 여러번 돔을 수정하게 하는게 아니라 이걸 모아서 한번에 Dom을 수정할 수 있게 해야된다.

이런건 서비스의 규모가 커질 수 록 점점 힘들어 짐

아주 단순한 웹 서비스를 구현할땐 간단하지만 실제로 개발ㅎ할 복잡한 웹 서비스는 다뤄야 할 서비스들도 많고 
동시에 발생하는 업데이트들도 많기 때문에 이건 매우 힘든 일이다

리엑트는 이걸 자동으로 진행해준다.

React는 이 과정을 자동으로 해준다. 
이렇게 동시에 발생하는 업데이트을을 모아서 수정 횟수를 최소화 하는 작업을 
리엑트에서는 딱히 신경쓰지 않아도 알아서 자동으로 처리해준다.

리엑트를 쓸때는 아무리 많은 업데이트를 동시에 발생시킨다 하더라도 대부분의 상황에서 충분히 빠른 속도로
업데이트를 구현할 수 있도록 도와준다는 것이다.


좀 더 살펴 보면

React는 
가상의 돔을 사용한다
Virtual DOM 이란?
- DOM을 자바스크립트 객체로 흉내낸 것으로 일종의 복제판이라고 생각하면 된다.
- React는 업데이트가 발생하면 실제로 DOM을 수정하기 전에 이 가상의 복제판 DOM에 먼저 반영해본다.
     - 연습 스윙 같은 느낌이라고 생각하면 된다.


React는 내부적으로 가상의 돔을 이용한다. 
실제 브라우저가 렌더링 하는 돔을 JavaScript 객체로 카피 해 놓은 것이라 생각하면 된다.

그래서 리엑트는 업데이트가 발생하면 실제 돔을 수정하는게 아니라 가상의 돔을 먼저 수정한다. 

동시에 3개의 업데이트가 발생했다 했을 때 실제 돔 대신 JS 객체인 Virtual Dom에 먼저 동시에 발생한 
업데이트 들을 순서대로 반영하고 

이렇게 동시에 발생한 업데이트 들이 다 모였다고 하면 한번에 실제 돔에 반영해준다.

그럼으로써 이 가상의 DOM이 버퍼 역할을 해서 
아무리 많은 수의 업데이트가 발생한다 하더라도 가상의 돔에 한번에 모였다가 반영이 되기 때문에 결국 최ㅗ한의 횟수로
돔이 수정이 되고 결론적으로는 조흔 업데이트 성능을 어느 정도 보장이 된다.



*/
